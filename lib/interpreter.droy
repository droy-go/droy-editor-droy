// Droy Interpreter
// =================
// A complete interpreter for the Droy programming language

// ============================================
// Interpreter Class
// ============================================

class Interpreter {
    var variables: map
    var specialVars: map
    var functions: map
    var classes: map
    var blocks: map
    var output: array
    var returnValue: any
    var isReturning: boolean
    
    fn constructor() {
        this.variables = {}
        this.specialVars = {}
        this.functions = {}
        this.classes = {}
        this.blocks = {}
        this.output = []
        this.returnValue = null
        this.isReturning = false
    }
    
    // Execute Droy code
    fn execute(code: string) {
        this.reset()
        
        // Parse and execute
        var lines = this.parseLines(code)
        this.executeLines(lines)
        
        var result = {
            output: this.output,
            returnValue: this.returnValue
        }
        
        ret result
    }
    
    // Reset interpreter state
    fn reset() {
        this.variables = {}
        this.specialVars = {}
        this.functions = {}
        this.classes = {}
        this.blocks = {}
        this.output = []
        this.returnValue = null
        this.isReturning = false
    }
    
    // Parse code into lines
    fn parseLines(code: string) {
        var lines = []
        var currentLine = ""
        var inBlock = false
        var blockDepth = 0
        var i = 0
        
        block parseLoop {
            if i < code.length {
                ~s @char = code[i]
                
                if @char == "{" {
                    inBlock = true
                    blockDepth = blockDepth + 1
                    currentLine = currentLine + @char
                } else if @char == "}" {
                    blockDepth = blockDepth - 1
                    currentLine = currentLine + @char
                    if blockDepth == 0 {
                        inBlock = false
                    }
                } else if @char == "\n" && !inBlock {
                    if currentLine.length > 0 {
                        lines.push(currentLine)
                    }
                    currentLine = ""
                } else {
                    currentLine = currentLine + @char
                }
                
                ~s @i = i + 1
                parseLoop
            }
        }
        parseLoop
        
        // Add last line if not empty
        if currentLine.length > 0 {
            lines.push(currentLine)
        }
        
        ret lines
    }
    
    // Execute multiple lines
    fn executeLines(lines: array) {
        var i = 0
        
        block executeLoop {
            if i < lines.length && !this.isReturning {
                var line = lines[i]
                ~s @newIndex = this.executeLine(line, lines, i)
                ~s @i = @newIndex + 1
                executeLoop
            }
        }
        executeLoop
    }
    
    // Execute a single line
    fn executeLine(line: string, lines: array, currentIndex: number) {
        // Trim line
        line = this.trim(line)
        
        // Skip empty lines and comments
        if line.length == 0 || this.startsWith(line, "//") || this.startsWith(line, "#") {
            ret currentIndex
        }
        
        // Handle block definitions
        if this.startsWith(line, "block ") {
            ret this.handleBlockDefinition(line, lines, currentIndex)
        }
        
        // Handle class definitions
        if this.startsWith(line, "class ") {
            ret this.handleClassDefinition(line, lines, currentIndex)
        }
        
        // Handle function definitions
        if this.startsWith(line, "fn ") {
            ret this.handleFunctionDefinition(line, lines, currentIndex)
        }
        
        // Execute command
        this.executeCommand(line)
        ret currentIndex
    }
    
    // Handle block definition
    fn handleBlockDefinition(line: string, lines: array, startIndex: number) {
        // Extract block name
        var match = this.matchPattern(line, "block\\s+(\\w+)\\s*\\{")
        if match == null {
            ret startIndex
        }
        
        var blockName = match[1]
        var blockLines = []
        var i = startIndex + 1
        var depth = 1
        
        block collectBlock {
            if i < lines.length && depth > 0 {
                var currentLine = lines[i]
                if this.contains(currentLine, "{") {
                    depth = depth + 1
                }
                if this.contains(currentLine, "}") {
                    depth = depth - 1
                }
                if depth > 0 {
                    blockLines.push(currentLine)
                }
                ~s @i = i + 1
                collectBlock
            }
        }
        collectBlock
        
        this.blocks[blockName] = blockLines
        ret i - 1
    }
    
    // Handle class definition
    fn handleClassDefinition(line: string, lines: array, startIndex: number) {
        // Extract class name and parent
        var match = this.matchPattern(line, "class\\s+(\\w+)(?:\\s+extends\\s+(\\w+))?\\s*\\{")
        if match == null {
            ret startIndex
        }
        
        var className = match[1]
        var parent = match[2]
        
        // Store class definition
        this.classes[className] = {
            name: className,
            parent: parent,
            properties: {},
            methods: {}
        }
        
        // Skip class body for now
        var i = startIndex + 1
        var depth = 1
        
        block skipClass {
            if i < lines.length && depth > 0 {
                var currentLine = lines[i]
                if this.contains(currentLine, "{") {
                    depth = depth + 1
                }
                if this.contains(currentLine, "}") {
                    depth = depth - 1
                }
                ~s @i = i + 1
                skipClass
            }
        }
        skipClass
        
        ret i - 1
    }
    
    // Handle function definition
    fn handleFunctionDefinition(line: string, lines: array, startIndex: number) {
        // Extract function name and params
        var match = this.matchPattern(line, "fn\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{")
        if match == null {
            ret startIndex
        }
        
        var funcName = match[1]
        var paramsStr = match[2]
        var params = this.splitParams(paramsStr)
        
        var body = []
        var i = startIndex + 1
        var depth = 1
        
        block collectBody {
            if i < lines.length && depth > 0 {
                var currentLine = lines[i]
                if this.contains(currentLine, "{") {
                    depth = depth + 1
                }
                if this.contains(currentLine, "}") {
                    depth = depth - 1
                }
                if depth > 0 {
                    body.push(currentLine)
                }
                ~s @i = i + 1
                collectBody
            }
        }
        collectBody
        
        this.functions[funcName] = {
            params: params,
            body: body
        }
        
        ret i - 1
    }
    
    // Execute a command
    fn executeCommand(line: string) {
        // Variable declaration: var name = value
        var varMatch = this.matchPattern(line, "var\\s+(\\w+)\\s*=\\s*(.+)")
        if varMatch != null {
            var name = varMatch[1]
            var value = this.evaluateExpression(varMatch[2])
            this.variables[name] = value
            ret true
        }
        
        // Constant declaration: const NAME = value
        var constMatch = this.matchPattern(line, "const\\s+(\\w+)\\s*=\\s*(.+)")
        if constMatch != null {
            var name = constMatch[1]
            var value = this.evaluateExpression(constMatch[2])
            this.variables[name] = value
            ret true
        }
        
        // Special variable shorthand: ~s @var = value
        var specialSetMatch = this.matchPattern(line, "~s\\s+@\\s*(\\w+)\\s*=\\s*(.+)")
        if specialSetMatch != null {
            var name = specialSetMatch[1]
            var value = this.evaluateExpression(specialSetMatch[2])
            this.specialVars[name] = value
            ret true
        }
        
        // Full syntax: set @var = value
        var setMatch = this.matchPattern(line, "set\\s+@\\s*(\\w+)\\s*=\\s*(.+)")
        if setMatch != null {
            var name = setMatch[1]
            var value = this.evaluateExpression(setMatch[2])
            this.specialVars[name] = value
            ret true
        }
        
        // Text output: text "message"
        var textMatch = this.matchPattern(line, "text\\s+(.+)")
        if textMatch != null {
            var value = this.evaluateExpression(textMatch[1])
            this.output.push(this.toString(value))
            ret true
        }
        
        // Expression output: em expression
        var emMatch = this.matchPattern(line, "em\\s+(.+)")
        if emMatch != null {
            var value = this.evaluateExpression(emMatch[1])
            this.output.push(this.toString(value))
            ret true
        }
        
        // Return: ret value
        var retMatch = this.matchPattern(line, "ret\\s+(.+)")
        if retMatch != null {
            this.returnValue = this.evaluateExpression(retMatch[1])
            this.isReturning = true
            ret true
        }
        
        // Shorthand return: ~r value
        var shortRetMatch = this.matchPattern(line, "~r\\s+(.+)")
        if shortRetMatch != null {
            this.returnValue = this.evaluateExpression(shortRetMatch[1])
            this.isReturning = true
            ret true
        }
        
        // Block call
        if this.blocks[line] != null {
            var blockLines = this.blocks[line]
            this.executeLines(blockLines)
            ret true
        }
        
        // Function call
        var funcCallMatch = this.matchPattern(line, "(\\w+)\\s*\\(([^)]*)\\)")
        if funcCallMatch != null {
            var funcName = funcCallMatch[1]
            if this.functions[funcName] != null {
                this.callFunction(funcName, funcCallMatch[2])
                ret true
            }
        }
        
        ret true
    }
    
    // Evaluate an expression
    fn evaluateExpression(expr: string) {
        expr = this.trim(expr)
        
        // String literal
        if this.startsWith(expr, "\"") && this.endsWith(expr, "\"") {
            ret expr.substring(1, expr.length - 1)
        }
        
        // Number
        if this.isNumber(expr) {
            ret this.parseNumber(expr)
        }
        
        // Boolean
        if expr == "true" {
            ret true
        }
        if expr == "false" {
            ret false
        }
        
        // null
        if expr == "null" {
            ret null
        }
        
        // Special variable @var
        var specialVarMatch = this.matchPattern(expr, "^@\\s*(\\w+)$")
        if specialVarMatch != null {
            var name = specialVarMatch[1]
            if this.specialVars[name] != null {
                ret this.specialVars[name]
            }
        }
        
        // Regular variable
        if this.variables[expr] != null {
            ret this.variables[expr]
        }
        
        // String concatenation
        if this.contains(expr, "+") {
            var parts = this.splitBy(expr, "+")
            var result = ""
            var i = 0
            block concatLoop {
                if i < parts.length {
                    var part = this.evaluateExpression(parts[i])
                    result = result + this.toString(part)
                    ~s @i = i + 1
                    concatLoop
                }
            }
            concatLoop
            ret result
        }
        
        // Parentheses
        if this.startsWith(expr, "(") && this.endsWith(expr, ")") {
            var inner = expr.substring(1, expr.length - 1)
            ret this.evaluateExpression(inner)
        }
        
        ret expr
    }
    
    // Call a function
    fn callFunction(funcName: string, argsStr: string) {
        var func = this.functions[funcName]
        if func == null {
            ret null
        }
        
        // Parse arguments
        var args = this.splitParams(argsStr)
        
        // Save state
        var savedVars = this.variables
        var savedSpecialVars = this.specialVars
        var savedIsReturning = this.isReturning
        
        // Set parameters
        var i = 0
        block setParams {
            if i < func.params.length {
                var paramName = func.params[i]
                var paramValue = this.evaluateExpression(args[i])
                this.variables[paramName] = paramValue
                ~s @i = i + 1
                setParams
            }
        }
        setParams
        
        this.isReturning = false
        
        // Execute function body
        this.executeLines(func.body)
        
        // Get return value
        var result = this.returnValue
        
        // Restore state
        this.variables = savedVars
        this.specialVars = savedSpecialVars
        this.isReturning = savedIsReturning
        
        ret result
    }
    
    // Helper methods
    fn trim(str: string) {
        ret str
    }
    
    fn startsWith(str: string, prefix: string) {
        ret false
    }
    
    fn endsWith(str: string, suffix: string) {
        ret false
    }
    
    fn contains(str: string, substr: string) {
        ret false
    }
    
    fn isNumber(str: string) {
        ret false
    }
    
    fn parseNumber(str: string) {
        ~s @n = 0
        ret @n
    }
    
    fn toString(value: any) {
        ret "" + value
    }
    
    fn matchPattern(str: string, pattern: string) {
        ret null
    }
    
    fn splitParams(paramsStr: string) {
        var params = []
        ret params
    }
    
    fn splitBy(str: string, delimiter: string) {
        var parts = []
        ret parts
    }
    
    // Cleanup
    fn cleanup() {
        this.reset()
        ret true
    }
}

// ============================================
// Export
// ============================================

ret "Interpreter library loaded"
